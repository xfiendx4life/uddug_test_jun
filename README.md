# Test task for Junior Position for Uddug
## Task
### User Story
Я, как пользователь, хочу иметь возможность смотреть графики в разных интервалах времени - месяц. неделя, день или час.
Требования
Написать функцию, которая первым аргументом принимает массив из структур данных для графика (структура указана ниже), а вторым необходимый интервал для форматирования.

### Структура данных:

```go
// Transaction is user transaction in exchange
Go
type Transaction struct {
	Value		int
	Timestamp     time.Time
}
```

### Test Data
```go
[]*Transaction{
	{
		4456,
		1616026248,
	},
	{
		4231,
		1616022648,
	},
	{
		5212,
		1616019048,
	},
	{
		4321,
		1615889448,
	},
	{
		4567,
		1615871448,
	},
}
```
### Out:
```go
{
	{
		4456,
		1616025600,
	},
	{
		4231,
		1615939200,
	},
	{
		4321,
		1615852800,
	},
}
```
## Implemantation

Реализация функции сделана в пакете `transaction` в функции `Format(transactions []*Transaction, interval string) []*Transaction`. 
Алгоритм реализации: 
* В тестовом примере слайс отсортирован по времени, но в задании этого не гарантируется, поэтому вначале сортировка слайса по убываеию времени
* За одну итерацию по слайсу, мы определяем последний элемент на промежутке (для получения промежутка используем функцию `roundPeriod(period time.Time, interval int) time.Time`) и добавляем его в результирующий слайс

Сложность алгоритма по времени примерно __O(n)__
Пространственная сложность __O(n)__  - мы записываем результат в новый слайс

## Running
Запуск функции происходит в пакете `main` для удобства тестирования данные подаются из файла в формате `json`, интервал и файл определяются флагами
```
-filename string
        file containing data to test function (default "input.json")
-interval string
    desireable interval to filter data [second, minute, hour, day, month, year] (default "day")
```
вывод происходит в файл `output.json`

Стандартный запуск можно сделать при помощи `Makefile`:
```
make run
```
Запустить тесты пакета `transaction` можно:
```
make test
```

### REMARK
Небольшое замечание. По условию поле `Timestamp` в структуре `Transaction` имеет тип `time.Time`, но подаются данные в unix-формате, поэтому я предполагаю, что они преобразуются в тип `time.Time` где-то в другом месте. В функции `main`, чтобы не писать кастомный анмаршаллер я использовал временный `map`.